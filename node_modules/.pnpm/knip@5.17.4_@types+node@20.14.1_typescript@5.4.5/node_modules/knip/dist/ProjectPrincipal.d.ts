import ts from 'typescript';
import { CacheConsultant } from './CacheConsultant.js';
import type { PrincipalOptions } from './PrincipalFactory.js';
import type { ReferencedDependencies } from './WorkspaceWorker.js';
import type { AsyncCompilers, SyncCompilers } from './compilers/types.js';
import type { SerializableExport, SerializableExportMember, SerializableFile, SerializableMap } from './types/serializable-map.js';
import type { SourceFileManager } from './typescript/SourceFileManager.js';
import { type GetImportsAndExportsOptions } from './typescript/getImportsAndExports.js';
import type { ResolveModuleNames } from './typescript/resolveModuleNames.js';
import type { ToSourceFilePath } from './util/to-source-path.js';
export declare class ProjectPrincipal {
    entryPaths: Set<string>;
    projectPaths: Set<string>;
    nonEntryPaths: Set<string>;
    referencedDependencies: Set<[string, string, string]>;
    skipExportsAnalysis: Set<string>;
    cwd: string;
    compilerOptions: ts.CompilerOptions;
    extensions: Set<string>;
    syncCompilers: SyncCompilers;
    asyncCompilers: AsyncCompilers;
    isSkipLibs: boolean;
    isWatch: boolean;
    cache: CacheConsultant<SerializableFile>;
    backend: {
        fileManager: SourceFileManager;
        compilerHost: ts.CompilerHost;
        resolveModuleNames: ResolveModuleNames;
        program?: ts.Program;
        typeChecker?: ts.TypeChecker;
        languageServiceHost: ts.LanguageServiceHost;
    };
    findReferences?: ts.LanguageService['findReferences'];
    constructor({ compilerOptions, cwd, compilers, isSkipLibs, isWatch, pkgName }: PrincipalOptions);
    init(toSourceFilePath: ToSourceFilePath): void;
    addPaths(paths: ts.CompilerOptions['paths']): void;
    addCompilers(compilers: [SyncCompilers, AsyncCompilers]): void;
    private createProgram;
    private hasAcceptedExtension;
    addEntryPath(filePath: string, options?: {
        skipExportsAnalysis: boolean;
    }): void;
    addEntryPaths(filePaths: Set<string> | string[], options?: {
        skipExportsAnalysis: boolean;
    }): void;
    addNonEntryPath(filePath: string): void;
    addProjectPath(filePath: string): void;
    deletedFiles: Set<unknown>;
    removeProjectPath(filePath: string): void;
    addReferencedDependencies(workspaceName: string, referencedDependencies: ReferencedDependencies): void;
    runAsyncCompilers(): Promise<void>;
    getUsedResolvedFiles(): string[];
    private getProgramSourceFiles;
    getUnreferencedFiles(): string[];
    analyzeSourceFile(filePath: string, options: Omit<GetImportsAndExportsOptions, 'skipExports'>, isGitIgnored: (filePath: string) => boolean, isPackageNameInternalWorkspace: (packageName: string) => boolean, getPrincipalByFilePath: (filePath: string) => undefined | ProjectPrincipal): SerializableFile;
    invalidateFile(filePath: string): void;
    findUnusedMembers(filePath: string, members: SerializableExportMember[]): SerializableExportMember[];
    hasExternalReferences(filePath: string, exportedItem: SerializableExport): boolean;
    reconcileCache(serializableMap: SerializableMap): void;
}
