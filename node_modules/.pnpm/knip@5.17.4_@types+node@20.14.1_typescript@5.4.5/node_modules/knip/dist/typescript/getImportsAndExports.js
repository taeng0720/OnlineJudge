import { isBuiltin } from 'node:module';
import ts from 'typescript';
import { ANONYMOUS, DEFAULT_EXTENSIONS, IMPORT_STAR } from '../constants.js';
import { timerify } from '../util/Performance.js';
import { isStartsLikePackageName, sanitizeSpecifier } from '../util/modules.js';
import { extname, isInNodeModules } from '../util/path.js';
import { shouldIgnore } from '../util/tag.js';
import { getAccessMembers, getDestructuredIds, getJSDocTags, getLineAndCharacterOfPosition, isAccessExpression, isConsiderReferencedNS, isDestructuring, } from './ast-helpers.js';
import getDynamicImportVisitors from './visitors/dynamic-imports/index.js';
import getExportVisitors from './visitors/exports/index.js';
import { getImportsFromPragmas } from './visitors/helpers.js';
import getImportVisitors from './visitors/imports/index.js';
import getScriptVisitors from './visitors/scripts/index.js';
const getVisitors = (sourceFile) => ({
    export: getExportVisitors(sourceFile),
    import: getImportVisitors(sourceFile),
    dynamicImport: getDynamicImportVisitors(sourceFile),
    script: getScriptVisitors(sourceFile),
});
const createMember = (node, member, pos) => {
    const { line, character } = node.getSourceFile().getLineAndCharacterOfPosition(pos);
    return {
        symbol: member.node.symbol,
        identifier: member.identifier,
        type: member.type,
        pos: member.pos,
        line: line + 1,
        col: character + 1,
        fix: member.fix,
        refs: 0,
        jsDocTags: getJSDocTags(member.node),
    };
};
const getImportsAndExports = (sourceFile, resolveModule, typeChecker, options) => {
    const { skipTypeOnly, tags } = options;
    const internalImports = new Map();
    const externalImports = new Set();
    const unresolvedImports = new Set();
    const resolved = new Set();
    const specifiers = new Set();
    const exports = new Map();
    const aliasedExports = new Map();
    const scripts = new Set();
    const importedInternalSymbols = new Map();
    const visitors = getVisitors(sourceFile);
    const addInternalImport = (options) => {
        const { identifier, symbol, filePath, namespace, specifier, isReExport } = options;
        const isStar = identifier === IMPORT_STAR;
        specifiers.add([specifier, filePath]);
        const file = internalImports.get(filePath);
        const imports = file ?? {
            reExportedBy: new Map(),
            reExportedAs: new Map(),
            reExportedNs: new Map(),
            imported: new Set(),
            importedAs: new Map(),
            importedNs: new Set(),
            refs: new Set(),
        };
        if (!file)
            internalImports.set(filePath, imports);
        if (isReExport) {
            if (isStar && namespace) {
                if (imports.reExportedNs.has(namespace)) {
                    imports.reExportedNs.get(namespace)?.add(sourceFile.fileName);
                }
                else {
                    imports.reExportedNs.set(namespace, new Set([sourceFile.fileName]));
                }
            }
            else if (namespace) {
                if (imports.reExportedAs.has(identifier)) {
                    imports.reExportedAs.get(identifier)?.add([namespace, sourceFile.fileName]);
                }
                else {
                    imports.reExportedAs.set(identifier, new Set([[namespace, sourceFile.fileName]]));
                }
            }
            else {
                if (imports.reExportedBy.has(identifier)) {
                    imports.reExportedBy.get(identifier)?.add(sourceFile.fileName);
                }
                else {
                    imports.reExportedBy.set(identifier, new Set([sourceFile.fileName]));
                }
            }
        }
        const alias = symbol ? String(symbol.escapedName) : options.alias;
        if (alias && alias !== identifier) {
            if (isStar) {
                imports.importedNs.add(alias);
            }
            else {
                if (imports.importedAs.has(alias))
                    imports.importedAs.get(alias)?.add(identifier);
                else
                    imports.importedAs.set(alias, new Set([identifier]));
            }
        }
        else if (identifier !== ANONYMOUS && identifier !== IMPORT_STAR) {
            imports.imported.add(identifier);
        }
        if (symbol && DEFAULT_EXTENSIONS.includes(extname(sourceFile.fileName))) {
            importedInternalSymbols.set(symbol, filePath);
        }
    };
    const addImport = (options, node) => {
        const { specifier, isTypeOnly, pos, identifier = ANONYMOUS, isReExport = false } = options;
        if (isBuiltin(specifier))
            return;
        const module = resolveModule(specifier);
        if (module) {
            const filePath = module.resolvedFileName;
            if (filePath) {
                if (options.resolve && !isInNodeModules(filePath)) {
                    resolved.add(filePath);
                    return;
                }
                if (!isInNodeModules(filePath)) {
                    addInternalImport({ ...options, identifier, filePath, isReExport });
                }
                if (module.isExternalLibraryImport) {
                    if (skipTypeOnly && isTypeOnly)
                        return;
                    const sanitizedSpecifier = sanitizeSpecifier(specifier);
                    if (!isStartsLikePackageName(sanitizedSpecifier)) {
                        return;
                    }
                    externalImports.add(sanitizedSpecifier);
                }
                else {
                    addInternalImport({ ...options, identifier, filePath, isReExport });
                }
            }
        }
        else {
            if (skipTypeOnly && isTypeOnly)
                return;
            if (shouldIgnore(getJSDocTags(node), tags))
                return;
            if (typeof pos === 'number') {
                const { line, character } = sourceFile.getLineAndCharacterOfPosition(pos);
                unresolvedImports.add({ specifier, pos, line: line + 1, col: character + 1 });
            }
            else {
                unresolvedImports.add({ specifier });
            }
        }
    };
    const maybeAddAccessExpressionAsNsImport = (namespace, member) => {
        const symbol = sourceFile.locals?.get(namespace);
        if (symbol) {
            const importedSymbolFilePath = importedInternalSymbols.get(symbol);
            if (importedSymbolFilePath) {
                const internalImport = internalImports.get(importedSymbolFilePath);
                if (internalImport) {
                    if (typeof member === 'string')
                        internalImport.refs.add(`${namespace}.${member}`);
                    else
                        for (const m of member)
                            internalImport.refs.add(`${namespace}.${m}`);
                }
            }
        }
    };
    const addExport = ({ node, symbol, identifier, type, pos, members = [], fix }) => {
        if (options.skipExports)
            return;
        if (symbol) {
            const importedSymbolFilePath = importedInternalSymbols.get(symbol);
            if (importedSymbolFilePath) {
                const importId = String(symbol.escapedName);
                const internalImport = internalImports.get(importedSymbolFilePath);
                if (internalImport) {
                    if (symbol.declarations && ts.isNamespaceImport(symbol.declarations[0])) {
                        if (internalImport.reExportedNs.has(identifier)) {
                            internalImport.reExportedNs.get(identifier)?.add(sourceFile.fileName);
                        }
                        else {
                            internalImport.reExportedNs.set(identifier, new Set([sourceFile.fileName]));
                        }
                    }
                    else if (importId === identifier) {
                        if (internalImport.reExportedBy.has(importId)) {
                            internalImport.reExportedBy.get(importId)?.add(sourceFile.fileName);
                        }
                        else {
                            internalImport.reExportedBy.set(importId, new Set([sourceFile.fileName]));
                        }
                    }
                    else {
                        if (internalImport.reExportedAs.has(importId)) {
                            internalImport.reExportedAs.get(importId)?.add(['default', sourceFile.fileName]);
                        }
                        else {
                            internalImport.reExportedAs.set(importId, new Set([['default', sourceFile.fileName]]));
                        }
                    }
                }
            }
        }
        const jsDocTags = getJSDocTags(node);
        const serializedMembers = members.map(member => createMember(node, member, member.pos));
        const item = exports.get(identifier);
        if (item) {
            const members = [...(item.members ?? []), ...serializedMembers];
            const tags = new Set([...(item.jsDocTags ?? []), ...jsDocTags]);
            const fixes = fix ? [...(item.fixes ?? []), fix] : item.fixes;
            exports.set(identifier, { ...item, members, jsDocTags: tags, fixes });
        }
        else {
            const { line, character } = node.getSourceFile().getLineAndCharacterOfPosition(pos);
            exports.set(identifier, {
                identifier,
                symbol: node.symbol,
                type,
                members: serializedMembers,
                jsDocTags,
                pos,
                line: line + 1,
                col: character + 1,
                fixes: fix ? [fix] : [],
                refs: 0,
            });
        }
        if (!jsDocTags.has('@alias')) {
            if (ts.isExportAssignment(node))
                maybeAddAliasedExport(node.expression, 'default');
            if (ts.isVariableDeclaration(node))
                maybeAddAliasedExport(node.initializer, identifier);
        }
    };
    const addScript = (script) => scripts.add(script);
    const maybeAddAliasedExport = (node, alias) => {
        const identifier = node?.getText();
        if (node && identifier) {
            const symbol = sourceFile.symbol?.exports?.get(identifier);
            if (symbol?.valueDeclaration) {
                if (!aliasedExports.has(identifier)) {
                    const pos = getLineAndCharacterOfPosition(symbol.valueDeclaration, symbol.valueDeclaration.pos);
                    aliasedExports.set(identifier, [{ symbol: identifier, ...pos }]);
                }
                const aliasedExport = aliasedExports.get(identifier);
                if (aliasedExport) {
                    const pos = getLineAndCharacterOfPosition(node, node.pos);
                    aliasedExport.push({ symbol: alias, ...pos });
                }
            }
        }
    };
    const visit = (node) => {
        const addImportWithNode = (result) => addImport(result, node);
        for (const visitor of visitors.dynamicImport) {
            const result = visitor(node, options);
            result && (Array.isArray(result) ? result.forEach(addImportWithNode) : addImportWithNode(result));
        }
        const isTopLevel = node.parent === sourceFile || node.parent?.parent === sourceFile;
        if (isTopLevel) {
            for (const visitor of visitors.import) {
                const result = visitor(node, options);
                result && (Array.isArray(result) ? result.forEach(addImportWithNode) : addImportWithNode(result));
            }
            for (const visitor of visitors.export) {
                const result = visitor(node, options);
                result && (Array.isArray(result) ? result.forEach(addExport) : addExport(result));
            }
        }
        for (const visitor of visitors.script) {
            const result = visitor(node, options);
            result && (Array.isArray(result) ? result.forEach(addScript) : addScript(result));
        }
        if (ts.isIdentifier(node)) {
            const id = String(node.escapedText);
            const symbol = sourceFile.locals?.get(id);
            if (symbol) {
                const importedSymbolFilePath = importedInternalSymbols.get(symbol);
                if (importedSymbolFilePath) {
                    if (!ts.isImportSpecifier(node.parent) &&
                        !ts.isImportEqualsDeclaration(node.parent) &&
                        !ts.isImportClause(node.parent) &&
                        !ts.isNamespaceImport(node.parent)) {
                        const imports = internalImports.get(importedSymbolFilePath);
                        if (imports) {
                            const isNotImported = !imports.importedNs.has(id) && !imports.importedAs.has(id) && !imports.imported.has(id);
                            if (isNotImported || isConsiderReferencedNS(node)) {
                                imports.refs.add(id);
                            }
                        }
                        if (isAccessExpression(node.parent)) {
                            if (isDestructuring(node.parent)) {
                                if (ts.isPropertyAccessExpression(node.parent)) {
                                    const ns = String(symbol.escapedName);
                                    const key = String(node.parent.name.escapedText);
                                    const members = getDestructuredIds(node.parent.parent.name).map(n => `${key}.${n}`);
                                    maybeAddAccessExpressionAsNsImport(ns, key);
                                    maybeAddAccessExpressionAsNsImport(ns, members);
                                }
                            }
                            else {
                                const members = getAccessMembers(typeChecker, node);
                                maybeAddAccessExpressionAsNsImport(id, members);
                            }
                        }
                        else if (isDestructuring(node)) {
                            const members = getDestructuredIds(node.parent.name);
                            maybeAddAccessExpressionAsNsImport(id, members);
                        }
                    }
                }
            }
        }
        if (isTopLevel &&
            ts.isImportEqualsDeclaration(node) &&
            ts.isQualifiedName(node.moduleReference) &&
            ts.isIdentifier(node.moduleReference.left)) {
            const { left, right } = node.moduleReference;
            if (sourceFile.locals?.get(left.text))
                maybeAddAccessExpressionAsNsImport(left.text, right.text);
        }
        if (ts.isTypeReferenceNode(node) && ts.isQualifiedName(node.typeName)) {
            const [ns, ...right] = [node.typeName.left.getText(), node.typeName.right.getText()].join('.').split('.');
            const members = right.map((_r, index) => right.slice(0, index + 1).join('.'));
            maybeAddAccessExpressionAsNsImport(ns, members);
        }
        ts.forEachChild(node, visit);
    };
    visit(sourceFile);
    const pragmaImports = getImportsFromPragmas(sourceFile);
    if (pragmaImports)
        for (const node of pragmaImports)
            addImport(node, sourceFile);
    const setRefs = (item) => {
        if (!item.symbol)
            return;
        const symbols = new Set();
        let index = 0;
        while (index < sourceFile.text.length && (index = sourceFile.text.indexOf(item.identifier, index)) !== -1) {
            const isDeclaration = index === item.pos || index === item.pos + 1;
            if (!isDeclaration) {
                const symbol = typeChecker.getSymbolAtLocation(ts.getTokenAtPosition(sourceFile, index));
                if (symbol) {
                    if (item.symbol === symbol) {
                        item.refs = 1;
                        break;
                    }
                    const declaration = symbol.declarations?.[0];
                    if (declaration) {
                        if (item.symbol === declaration.name?.flowNode?.node?.symbol) {
                            item.refs = 1;
                            break;
                        }
                        if (ts.isImportSpecifier(declaration) && symbols.has(symbol)) {
                            item.refs = 1;
                            break;
                        }
                    }
                    symbols.add(symbol);
                }
            }
            index += item.identifier.length;
        }
    };
    for (const item of exports.values()) {
        if (options.ignoreExportsUsedInFile)
            setRefs(item);
        for (const member of item.members) {
            setRefs(member);
            member.symbol = undefined;
        }
        item.symbol = undefined;
    }
    return {
        imports: {
            internal: internalImports,
            external: externalImports,
            resolved,
            specifiers,
            unresolved: unresolvedImports,
        },
        exports: {
            exported: exports,
            duplicate: [...aliasedExports.values()],
        },
        scripts,
    };
};
export const _getImportsAndExports = timerify(getImportsAndExports);
