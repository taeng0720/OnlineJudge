"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProcessMemoryData = exports.getMemoryData = exports.getProcessCpuUsageData = exports.getCpuUsageData = void 0;
const os = require("os");
const MILLISECOND = 1 / 1e3;
let cpuUsageTime = undefined;
/**
 * It returns cpu load delta from last time - to be used with SumObservers.
 * When called first time it will return 0 and then delta will be calculated
 */
function getCpuUsageData() {
    if (typeof cpuUsageTime !== 'number') {
        cpuUsageTime = new Date().getTime() - process.uptime() * 1000;
    }
    const timeElapsed = (new Date().getTime() - cpuUsageTime) / 1000;
    return os.cpus().map((cpu, cpuNumber) => {
        const idle = cpu.times.idle * MILLISECOND;
        const user = cpu.times.user * MILLISECOND;
        const system = cpu.times.sys * MILLISECOND;
        const interrupt = cpu.times.irq * MILLISECOND;
        const nice = cpu.times.nice * MILLISECOND;
        const idleP = idle / timeElapsed;
        const userP = user / timeElapsed;
        const systemP = system / timeElapsed;
        const interruptP = interrupt / timeElapsed;
        const niceP = nice / timeElapsed;
        return {
            cpuNumber: String(cpuNumber),
            idle,
            user,
            system,
            interrupt,
            nice,
            userP,
            systemP,
            idleP,
            interruptP,
            niceP,
        };
    });
}
exports.getCpuUsageData = getCpuUsageData;
/**
 * It returns process cpu load delta from last time - to be used with SumObservers.
 * When called first time it will return 0 and then delta will be calculated
 */
function getProcessCpuUsageData() {
    if (typeof cpuUsageTime !== 'number') {
        cpuUsageTime = new Date().getTime() - process.uptime() * 1000;
    }
    const timeElapsed = (new Date().getTime() - cpuUsageTime) / 1000;
    const cpuUsage = process.cpuUsage();
    const user = cpuUsage.user * MILLISECOND;
    const system = cpuUsage.system * MILLISECOND;
    const userP = user / timeElapsed;
    const systemP = system / timeElapsed;
    return {
        user,
        system,
        userP,
        systemP,
    };
}
exports.getProcessCpuUsageData = getProcessCpuUsageData;
/**
 * Returns memory data as absolute values
 */
function getMemoryData() {
    const total = os.totalmem();
    const free = os.freemem();
    const used = total - free;
    const freeP = free / total;
    const usedP = used / total;
    return {
        used: used,
        free: free,
        usedP: usedP,
        freeP: freeP, // this is frac part (0-1)
    };
}
exports.getMemoryData = getMemoryData;
/**
 * Returns process memory RSS
 * The Resident Set Size, is the amount of space occupied in the main memory device (that is a subset of the total allocated memory) for the process,
 * including all C++ and JavaScript objects and code.
 */
function getProcessMemoryData() {
    // `process.memoryUsage.rss` is a faster alternative introduced in v14.18.0.
    // Prefer it if available.
    if (process.memoryUsage.rss) {
        return process.memoryUsage.rss();
    }
    return process.memoryUsage().rss;
}
exports.getProcessMemoryData = getProcessMemoryData;
//# sourceMappingURL=common.js.map