'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var lezerClojure = require('@nextjournal/lezer-clojure');
var highlight = require('@lezer/highlight');
var language = require('@codemirror/language');

/**
A language provider based on the [Lezer Clojure](https://github.com/nextjournal/lezer-clojure), extended with
highlighting and indentation information.
*/
const { coll } = lezerClojure.props;
// debug
// const nodeText = (state, node: SyntaxNode) => { return state.doc.sliceString(node.from, node.to) }
const clojureLanguage = language.LRLanguage.define({
    parser: lezerClojure.parser.configure({
        props: [highlight.styleTags({ NS: highlight.tags.keyword,
                DefLike: highlight.tags.keyword,
                "Operator/Symbol": highlight.tags.keyword,
                "VarName/Symbol": highlight.tags.definition(highlight.tags.variableName),
                // Symbol: tags.keyword,
                // "'": tags.keyword, // quote
                Boolean: highlight.tags.atom,
                "DocString/...": highlight.tags.emphasis,
                "Discard!": highlight.tags.comment,
                Number: highlight.tags.number,
                StringContent: highlight.tags.string,
                "\"\\\"\"": highlight.tags.string,
                Keyword: highlight.tags.atom,
                Nil: highlight.tags.null,
                LineComment: highlight.tags.lineComment,
                RegExp: highlight.tags.regexp }),
            language.indentNodeProp.add((nodeType) => {
                return (context) => {
                    let { pos, unit, node, state, baseIndent, textAfter } = context;
                    if (nodeType.prop(coll)) {
                        // same behaviour as in clojure-mode: args after operator are always 2-units indented
                        let parentBase = context.column(node.firstChild.to); // column at the right of parent opening-(
                        if ("List" == nodeType.name && ["NS", "DefLike", "Operator"].includes(node.firstChild.nextSibling.type.name)) {
                            return parentBase + 1;
                        }
                        else {
                            return parentBase;
                        }
                    }
                    else {
                        return 0;
                    }
                };
            }),
            language.foldNodeProp.add({ ["Vector Map List"]: language.foldInside })]
    }),
    languageData: { commentTokens: { line: ";;" } }
});
function clojure() {
    return new language.LanguageSupport(clojureLanguage);
}

exports.clojure = clojure;
exports.clojureLanguage = clojureLanguage;
